---
title: "Biostat 203B Homework 2"
subtitle: Due Feb 9 @ 11:59PM
author: Yuxin Zhang UID:406328706
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
knitr:
  opts_chunk: 
    cache: false    
    echo: true
    fig.align: 'center'
    fig.width: 6
    fig.height: 4
    message: FALSE
execute:
  eval: True   
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```

Load necessary libraries (you can add more as needed).
```{r setup}
library(arrow)
library(data.table)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```

Display memory information of your computer
```{r}
memuse::Sys.meminfo()
```

In this exercise, we explore various tools for ingesting the [MIMIC-IV](https://mimic.mit.edu/docs/iv/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2024winter/hw/hw1/hw1.html).

Display the contents of MIMIC `hosp` and `icu` data folders:

```{bash}
ls -l ~/mimic/hosp/
```

```{bash}
ls -l ~/mimic/icu/
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

### Q1.1 Speed, memory, and data types

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three functions: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the data.table package.

Which function is fastest? Is there difference in the (default) parsed data types? How much memory does each resultant dataframe or tibble use? (Hint: `system.time` measures run times; `pryr::object_size` measures memory usage.) 


```{r}
# time of `read_csv` in tidyverse
system.time({
  ad_read_csv <- "~/mimic/hosp/admissions.csv.gz" %>%
    read_csv()
})
```

```{r}
# time of `read.csv` in base R
system.time({
  ad_read_csv_base <- "~/mimic/hosp/admissions.csv.gz" %>% read.csv()
})
```

```{r}
# time of `fread` in the data.table package
system.time({
  ad_fread <- "~/mimic/hosp/admissions.csv.gz" %>% fread()
})
```

```{r}
str(ad_read_csv)
str(ad_read_csv_base)
str(ad_fread)
```

```{r}
# memory use
object_size(ad_read_csv)
object_size(ad_read_csv_base)
object_size(ad_fread )
```
**Answer:**
Function `fread` in the data.table package is the fastest. <br>
The (default) parsed data types are different. Numeric columns are parsed as double only by `read_csv`, while the other two function parse them as integer. Date/time columns are parsed as character by `read.csv` and as POSIXct by `read_csv` and `fread`. <br>
The ad_read_csv generated by `read_csv` uses 55.31MB. The ad_read_csv_base generated by `read.csv` uses 158.71 MB. The ad_fread generated by `fread` uses 50.13 MB. <br>


### Q1.2 User-supplied data types

Re-ingest `admissions.csv.gz` by indicating appropriate column data types in `read_csv`. Does the run time change? How much memory does the result tibble use? (Hint: `col_types` argument in `read_csv`.)

```{r}
col_types <- cols(
  subject_id = col_double(),
  hadm_id = col_double(),
  admittime = col_datetime(format = ""),
  dischtime = col_datetime(format = ""),
  deathtime = col_datetime(format = ""),
  admission_type = col_character(),
  admit_provider_id = col_character(),
  admission_location = col_character(),
  discharge_location = col_character(),
  insurance = col_character(),
  language = col_character(),
  marital_status = col_character(),
  race = col_character(),
  edregtime = col_datetime(format = ""),
  edouttime = col_datetime(format = ""),
  hospital_expire_flag = col_double()
)

system.time({
  read_csv_col <- "~/mimic/hosp/admissions.csv.gz" %>%
    read_csv(col_types = col_types) 
})

object_size(read_csv_col)
```
The run time changes. The result tibble uses 55.31 MB.

## Q2. Ingest big data files

<p align="center">
  <img src="https://raw.githubusercontent.com/ucla-biostat-203b/2024winter/main/hw/hw2/bigfile.png" width="50%">
</p>

Let us focus on a bigger file, `labevents.csv.gz`, which is about 125x bigger than `admissions.csv.gz`.
```{bash}
ls -l ~/mimic/hosp/labevents.csv.gz
```
Display the first 10 lines of this file.
```{bash}
zcat < ~/mimic/hosp/labevents.csv.gz | head -10
```

### Q2.1 Ingest `labevents.csv.gz` by `read_csv`

<p align="center">
  <img src="https://raw.githubusercontent.com/ucla-biostat-203b/2024winter/main/hw/hw2/readr_logo.png" width="20%">
</p>

Try to ingest `labevents.csv.gz` using `read_csv`. What happens? If it takes more than 5 minutes on your computer, then abort the program and report your findings. 

```{r}
#| eval: false
read_csv("~/mimic/hosp/labevents.csv.gz" )
```

It seems that the file has a large size and it takes a long time for the function `read_csv` to ingest it. I can not read it in 5 minutes, so I abort it.

### Q2.2 Ingest selected columns of `labevents.csv.gz` by `read_csv`

Try to ingest only columns `subject_id`, `itemid`, `charttime`, and `valuenum` in `labevents.csv.gz` using `read_csv`.  Does this solve the ingestion issue? (Hint: `col_select` argument in `read_csv`.)

```{r}
#| eval: false
selected_columns <- c("subject_id", "itemid", "charttime", "valuenum")
read_csv("~/mimic/hosp/labevents.csv.gz", col_select = selected_columns)
```

This code doesn't finish within 3 minutes on my computer. This is due to the large size of `labevents.csv.gz`. Specifying the col_select argument doesn't optimize the file reading process. Even though we're only interested in specific columns, the entire file still needs to be decompressed and parsed initially. 

### Q2.3 Ingest subset of `labevents.csv.gz`

<p align="center">
  <img src="https://raw.githubusercontent.com/ucla-biostat-203b/2024winter/main/hw/hw2/linux_logo.png" width="20%">
</p>

Our first strategy to handle this big data file is to make a subset of the `labevents` data.  Read the [MIMIC documentation](https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) for the content in data file `labevents.csv`.

In later exercises, we will only be interested in the following lab items: creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931) and the following columns: `subject_id`, `itemid`, `charttime`, `valuenum`. Write a Bash command to extract these columns and rows from `labevents.csv.gz` and save the result to a new file `labevents_filtered.csv.gz` in the current working directory. (Hint: use `zcat <` to pipe the output of `labevents.csv.gz` to `awk` and then to `gzip` to compress the output. To save render time, put `#| eval: false` at the beginning of this code chunk.)

Display the first 10 lines of the new file `labevents_filtered.csv.gz`. How many lines are in this new file? How long does it take `read_csv` to ingest `labevents_filtered.csv.gz`?


```{bash}
#| eval: false
zcat < ~/mimic/hosp/labevents.csv.gz | \
awk -F, 'BEGIN {OFS=","} NR==1 || \
($5==50912 || $5==50971 || $5==50983 || \
$5==50902 || $5==50882 || $5==51221 || \
$5==51301 || $5==50931) {print $2, $5, $7, $10}' | \
gzip > labevents_filtered.csv.gz
```

```{bash}
zcat < labevents_filtered.csv.gz | head -10
zcat < labevents_filtered.csv.gz | wc -l
```

```{r}
system.time({
  labevents_filtered <- read_csv("labevents_filtered.csv.gz")
})
```

There are 24855910 lines in the new file including the header  and the time is shown as above. 

### Q2.4 Ingest `labevents.csv` by Apache Arrow

<p align="center">
  <img src="https://raw.githubusercontent.com/ucla-biostat-203b/2024winter/main/hw/hw2/arrow_logo.png" width="30%">
</p>

Our second strategy is to use [Apache Arrow](https://arrow.apache.org/) for larger-than-memory data analytics. Unfortunately Arrow does not work with gz files directly. First decompress `labevents.csv.gz` to `labevents.csv` and put it in the current working directory. To save render time, put `#| eval: false` at the beginning of this code chunk.

Then use [`arrow::open_dataset`](https://arrow.apache.org/docs/r/reference/open_dataset.html) to ingest `labevents.csv`, select columns, and filter `itemid` as in Q2.3. How long does the ingest+select+filter process take? Display the number of rows and the first 10 rows of the result tibble, and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is Apache Arrow. Imagine you want to explain it to a layman in an elevator. 


```{bash}
#| eval: false
zcat< ~/mimic/hosp/labevents.csv.gz > labevents.csv
```

```{r}
system.time({
  labevents <- arrow::open_dataset(
    "labevents.csv", 
    format = "csv"
  ) %>%
  filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
  select(subject_id, itemid, charttime, valuenum) %>%
  collect()
})

nrow(labevents)

sorted_labevents <- labevents %>%
  arrange(subject_id, charttime, itemid)
head(sorted_labevents, 10)
```

Apache Arrow is like a super-efficient translator for data. It takes information stored in different languages and organizes it in a way that computers can understand really quickly. This means that programs can work with the data much faster, whether they're running on regular computers or powerful graphics processors. It's a tool that makes it easier for different computer programs to share and analyze data, no matter what language they speak.


### Q2.5 Compress `labevents.csv` to Parquet format and ingest/select/filter

<p align="center">
  <img src="https://raw.githubusercontent.com/ucla-biostat-203b/2024winter/main/hw/hw2/parquet_logo.png" width="30%">
</p>

Re-write the csv file `labevents.csv` in the binary Parquet format (Hint: [`arrow::write_dataset`](https://arrow.apache.org/docs/r/reference/write_dataset.html).) How large is the Parquet file(s)? How long does the ingest+select+filter process of the Parquet file(s) take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is the Parquet format. Imagine you want to explain it to a layman in an elevator.

```{r}
labevents_csv <- arrow::open_dataset("labevents.csv", format = "csv")
arrow::write_dataset(labevents_csv, "labevents.parquet")
labevents_parquet <- arrow::open_dataset("labevents.parquet")
```

```{r}
# time for running the ingest+select+filter process of the Parquet file(s) 
system.time({
  labevents_filitered_parquet <- labevents_parquet %>%
    dplyr::filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
    dplyr::select(subject_id, itemid, charttime, valuenum) %>%
    collect()
})
# the number of rows
nrow(labevents_filitered_parquet)
```

```{bash}
ls -l labevents.parquet
```

```{r}
sorted_labevents_parquet <- labevents_filitered_parquet %>%
  arrange(subject_id, charttime, itemid)
head(sorted_labevents_parquet, 10)
```

The Parquet file is in size of 2069791662 bytes and has 24855909 rows.

Parquet is an open source, column-oriented data file format, designed to store and retrieve information in a really smart way. Data within Parquet files is stored in a columnar format, meaning that values from the same column are stored together. Parquet organizes data neatly and makes it quicker for your computer to find and work with the information you need, while also saving space. 

### Q2.6 DuckDB

<p align="center">
  <img src="https://raw.githubusercontent.com/ucla-biostat-203b/2024winter/main/hw/hw2/duckdb_logo.png" width="20%">
</p>

Ingest the Parquet file, convert it to a DuckDB table by [`arrow::to_duckdb`](https://arrow.apache.org/docs/r/reference/to_duckdb.html), select columns, and filter rows as in Q2.5. How long does the ingest+convert+select+filter process take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)
Write a few sentences to explain what is DuckDB. Imagine you want to explain it to a layman in an elevator.

```{r}
# time for ingest+convert+select+filter process
system.time({
  labevents_duckdb <- arrow::open_dataset(
    "labevents.parquet") %>%
    arrow::to_duckdb(table_name = "labevents_table") %>%
    dplyr::filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931)) %>%
    dplyr::select(subject_id, itemid, charttime, valuenum) %>%
    collect()
})
```

```{r}
# number of rows
nrow(labevents_duckdb)
```

```{r}
# the first 10 rows
sorted_labevents_duckdb <- labevents_duckdb %>%
  arrange(subject_id, charttime, itemid)
head(sorted_labevents_duckdb, 10)
```

The file has 24855909 rows.

DuckDB is a versatile database management system known for its flexibility and performance. It offers a flexible extension mechanism that allows users to define new data types, functions, file formats, and even new SQL syntax, catering to specific needs and scenarios. Moreover, DuckDB excels in high-speed data transfer capabilities, enabling rapid movement of data to and from the database. This feature accelerates data processing workflows, ensuring quick ingestion, querying, and analysis of large datasets. 

## Q3. Ingest and filter `chartevents.csv.gz`

[`chartevents.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head -10
```
[`d_items.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the `itemid` in `chartevents.csv.gz`.
```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head -10
```
In later exercises, we are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items, using the favorite method you learnt in Q2. 

Document the steps and show code. Display the number of rows and the first 10 rows of the result tibble.

Step 1: decompress `chartevents.csv.gz` to `chartevents.csv`
```{bash}
#| eval: false
zcat< ~/mimic/icu/chartevents.csv.gz > chartevents.csv
```

Step 2: Re-write the csv file `chartevents.csv` in the binary Parquet format
```{r}
chartevents_csv <- arrow::open_dataset("chartevents.csv", format = "csv")
arrow::write_dataset(chartevents_csv, "chartevents.parquet")
```

Step 3: filter the itemid in 220045, 220181, 220179, 223761, 220210
```{r}
chartevents_parquet <- arrow::open_dataset(
    "chartevents.parquet") %>%
    dplyr::filter(itemid %in% c(220045, 220181, 220179, 223761, 220210)) %>%
    collect()
```

```{r}
nrow(chartevents_parquet)
head(chartevents_parquet, 10)
```












